generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

enum MatchStatus {
  scheduled
  locked
  played
  canceled
}

enum Role {
  USER
  ADMIN
}

model User {
  id             String             @id @default(uuid()) @db.Uuid
  email          String             @unique
  username       String             @unique
  passwordHash   String
  role           Role               @default(USER)
  createdAt      DateTime           @default(now())
  updatedAt      DateTime           @updatedAt
  matches          Match[]
  participations   MatchParticipant[]
  ownedGroups      Group[]       @relation("GroupOwner")
  groupMemberships GroupMember[]
}

model Match {
  id           String             @id @default(uuid()) @db.Uuid
  title        String
  startsAt     DateTime
  location     String?
  capacity     Int
  status       MatchStatus        @default(scheduled)
  revision     Int                @default(1)
  isLocked     Boolean            @default(false)
  lockedAt     DateTime?
  lockedBy     String?            @db.Uuid
  createdById  String             @db.Uuid
  createdBy    User               @relation(fields: [createdById], references: [id])
  createdAt    DateTime           @default(now())
  updatedAt    DateTime           @updatedAt
  participants MatchParticipant[]

  @@index([createdById], map: "Match_createdById_idx")
  @@index([startsAt], map: "Match_startsAt_idx")
}

enum MatchParticipantStatus {
  INVITED
  CONFIRMED
  WAITLISTED
  DECLINED
  WITHDRAWN
}

model MatchParticipant {
  id               String                 @id @default(uuid()) @db.Uuid
  matchId          String                 @db.Uuid
  userId           String                 @db.Uuid
  status           MatchParticipantStatus
  waitlistPosition Int?
  confirmedAt      DateTime?
  isMatchAdmin     Boolean                @default(false)
  adminGrantedAt   DateTime?
  createdAt        DateTime               @default(now())
  updatedAt        DateTime               @updatedAt

  match Match @relation(fields: [matchId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id])

  @@unique([matchId, userId], map: "MatchParticipant_matchId_userId_key")
  @@index([matchId, status], map: "MatchParticipant_matchId_status_idx")
  @@index([matchId, waitlistPosition], map: "MatchParticipant_matchId_waitlistPosition_idx")
  @@index([matchId, createdAt], map: "MatchParticipant_matchId_createdAt_idx")
  @@index([userId, matchId], map: "MatchParticipant_userId_matchId_idx")
}

model Group {
  id        String        @id @default(uuid()) @db.Uuid
  name      String
  ownerId   String        @db.Uuid
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt
  owner     User          @relation("GroupOwner", fields: [ownerId], references: [id])
  members   GroupMember[]

  @@index([ownerId])
}

model GroupMember {
  groupId   String   @db.Uuid
  userId    String   @db.Uuid
  createdAt DateTime @default(now())
  group     Group    @relation(fields: [groupId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id])

  @@id([groupId, userId])
  @@index([userId])
}

model IdempotencyRecord {
  id           String   @id @default(uuid()) @db.Uuid
  key          String
  actorId      String   @db.Uuid
  route        String
  matchId      String?  @db.Uuid
  requestHash  String
  statusCode   Int      @default(200)
  responseJson Json
  expiresAt    DateTime
  createdAt    DateTime @default(now())

  @@unique([key, actorId, route], map: "IdempotencyRecord_key_actorId_route_key")
  @@index([expiresAt], map: "IdempotencyRecord_expiresAt_idx")
}
